diff --git a/src/pool.c b/src/pool.c
index 58f3f7087..49f482e22 100644
--- a/src/pool.c
+++ b/src/pool.c
@@ -191,17 +191,17 @@ static void free_blocks(union block_hdr *blok, const char *pool_tag) {
  */
 
 static union block_hdr *new_block(int minsz, int exact) {
-  union block_hdr **lastptr = &block_freelist;
+/*  union block_hdr **lastptr = &block_freelist;
   union block_hdr *blok = block_freelist;
 
   if (!exact) {
     minsz = 1 + ((minsz - 1) / BLOCK_MINFREE);
     minsz *= BLOCK_MINFREE;
-  }
+  }*/
 
   /* Check if we have anything of the requested size on our free list first...
    */
-  while (blok) {
+/*  while (blok) {
     if (minsz <= ((char *) blok->h.endp - (char *) blok->h.first_avail)) {
       *lastptr = blok->h.next;
       blok->h.next = NULL;
@@ -212,7 +212,7 @@ static union block_hdr *new_block(int minsz, int exact) {
 
     lastptr = &blok->h.next;
     blok = blok->h.next;
-  }
+  }*/
 
   /* Nope...damn.  Have to malloc() a new one. */
   stat_malloc++;
@@ -480,6 +480,7 @@ static void pool_release_free_block_list(void) {
 }
 
 struct pool_rec *make_sub_pool(struct pool_rec *p) {
+  return pr_pool_create_sz(p, 0);
   union block_hdr *blok;
   pool *new_pool;
 
@@ -511,6 +512,7 @@ struct pool_rec *make_sub_pool(struct pool_rec *p) {
 }
 
 struct pool_rec *pr_pool_create_sz(struct pool_rec *p, size_t sz) {
+  sz = 0;
   union block_hdr *blok;
   pool *new_pool;
 
@@ -662,6 +664,7 @@ static void *alloc_pool(struct pool_rec *p, size_t reqsz, int exact) {
   new_first_avail = first_avail + sz;
 
   if (new_first_avail <= (char *) blok->h.endp) {
+    assert(0); // must be unreachable:
     blok->h.first_avail = new_first_avail;
     return (void *) first_avail;
   }
diff --git a/src/signals.c b/src/signals.c
index 828717e7a..74e6bf182 100644
--- a/src/signals.c
+++ b/src/signals.c
@@ -530,11 +530,11 @@ static void handle_signals(int delay_on_eintr) {
 }
 
 void pr_signals_handle(void) {
-  handle_signals(TRUE);
+  //handle_signals(TRUE);
 }
 
 void pr_signals_handle_without_delay(void) {
-  handle_signals(FALSE);
+  //handle_signals(FALSE);
 }
 
 /* sig_restart occurs in the master daemon when manually "kill -HUP"
@@ -588,6 +588,7 @@ RETSIGTYPE pr_signals_handle_event(int signo) {
 }
 
 int init_signals(void) {
+  return 0;
   sigset_t sig_set;
 
   /* Should the master server (only applicable in standalone mode)
