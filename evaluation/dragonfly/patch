diff --git a/modules/mod_delay.c b/modules/mod_delay.c
index 6bb46f6b4..c4cff1867 100644
--- a/modules/mod_delay.c
+++ b/modules/mod_delay.c
@@ -2172,6 +2172,10 @@ static cmdtable delay_cmdtab[] = {
   { 0, NULL }
 };
 
+static int nop(void) {
+    return 0;
+}
+
 module delay_module = {
   NULL, NULL,
 
@@ -2182,19 +2186,19 @@ module delay_module = {
   "delay",
 
   /* Module configuration handler table */
-  delay_conftab,
+  NULL,
 
   /* Module command handler table */
-  delay_cmdtab,
+  NULL,
 
   /* Module authentication handler table */
   NULL,
 
   /* Module initialization function */
-  delay_init,
+  nop,
 
   /* Session initialization function */
-  delay_sess_init,
+  nop,
 
   /* Module version */
   MOD_DELAY_VERSION
diff --git a/modules/mod_rlimit.c b/modules/mod_rlimit.c
index b5729f52e..aea9fa76b 100644
--- a/modules/mod_rlimit.c
+++ b/modules/mod_rlimit.c
@@ -576,7 +576,7 @@ static int rlimit_set_core(int scope) {
      * so when possible, use PR_SET_DUMPABLE to ensure that no coredumps
      * happen.
      */
-    if (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0) {
+    if (prctl(PR_SET_DUMPABLE, 1, 1, 1, 1) < 0) {
       pr_log_pri(PR_LOG_ERR, "error setting PR_SET_DUMPABLE to false: %s",
         strerror(errno));
     }
@@ -710,6 +710,7 @@ static int rlimit_set_files(int scope) {
 }
 
 static int rlimit_set_memory(int scope) {
+  return 0;
   config_rec *c;
 
   /* Now check for the configurable resource limits */
diff --git a/src/fsio.c b/src/fsio.c
index ac4e83b9e..860bbc700 100644
--- a/src/fsio.c
+++ b/src/fsio.c
@@ -6696,6 +6696,7 @@ char *pr_fsio_getline(char *buf, size_t buflen, pr_fh_t *fh,
 #define FSIO_MAX_FD_COUNT		1024
 
 void pr_fs_close_extra_fds(void) {
+  return;
   register unsigned int i;
   long nfiles = 0;
   struct rlimit rlim;
diff --git a/src/main.c b/src/main.c
index d4ae3186b..bc20f58e8 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1300,7 +1300,7 @@ static void fork_server(int fd, conn_t *l, unsigned char no_fork) {
   pr_signals_block();
   PRIVS_ROOT
 
-  log_opensyslog(NULL);
+  //log_opensyslog(NULL);
 
   PRIVS_RELINQUISH
   pr_signals_unblock();
@@ -1565,6 +1565,10 @@ static void daemon_loop(void) {
 
   pr_proctitle_set("(accepting connections)");
 
+#ifdef __AFL_HAVE_MANUAL_CONTROL
+  __AFL_INIT();
+#endif
+
   time(&last_error);
 
   while (TRUE) {
diff --git a/src/memcache.c b/src/memcache.c
index 0eee5466e..2f47666aa 100644
--- a/src/memcache.c
+++ b/src/memcache.c
@@ -1523,7 +1523,7 @@ static void memcache_tpl_fatal(char *fmt, ...) {
   pr_trace_vmsg(trace_channel, 1, fmt, ap);
   va_end(ap);
 
-  _exit(1);
+  exit(1);
 }
 
 int memcache_clear(void) {
diff --git a/src/rlimit.c b/src/rlimit.c
index a874f8019..afcaf0b53 100644
--- a/src/rlimit.c
+++ b/src/rlimit.c
@@ -151,6 +151,7 @@ int pr_rlimit_get_memory(rlim_t *current, rlim_t *max) {
 }
 
 int pr_rlimit_set_memory(rlim_t current, rlim_t max) {
+  return 0;
 #if defined(RLIMIT_AS)
   return set_rlimit(RLIMIT_AS, current, max);
 
diff --git a/src/session.c b/src/session.c
index b32301bee..5e782161e 100644
--- a/src/session.c
+++ b/src/session.c
@@ -168,7 +168,7 @@ void pr_session_end(int flags) {
    */
   exit(exitcode);
 #else
-  _exit(exitcode);
+  exit(exitcode);
 #endif /* PR_DEVEL_PROFILE */
 }
 
diff --git a/src/table.c b/src/table.c
index 5f16f2952..cb26aa060 100644
--- a/src/table.c
+++ b/src/table.c
@@ -356,6 +356,7 @@ static void tab_entry_remove(pr_table_t *tab, pr_table_entry_t *e) {
 }
 
 static unsigned int tab_get_seed(void) {
+  return 1234;
   unsigned int seed = 0;
 #ifndef PR_USE_OPENSSL
   int fd = -1;
diff --git a/src/throttle.c b/src/throttle.c
index 106e6ae68..96aa1ff91 100644
--- a/src/throttle.c
+++ b/src/throttle.c
@@ -290,7 +290,7 @@ void pr_throttle_pause(off_t xferlen, int xfer_ending) {
     /* No interruptions, please... */
     xfer_rate_sigmask(TRUE);
 
-    if (select(0, NULL, NULL, NULL, &tv) < 0) {
+    if (/*select(0, NULL, NULL, NULL, &tv) <*/ 0) {
       int xerrno = errno;
 
       if (XFER_ABORTED) {
diff --git a/src/timers.c b/src/timers.c
index 23b210e6f..ca4e2e704 100644
--- a/src/timers.c
+++ b/src/timers.c
@@ -525,6 +525,7 @@ static int sleep_cb(CALLBACK_FRAME) {
 }
 
 int pr_timer_sleep(int seconds) {
+  return 0;
   int timerno = 0;
   sigset_t oset;
 
@@ -551,6 +552,7 @@ int pr_timer_sleep(int seconds) {
 }
 
 int pr_timer_usleep(unsigned long usecs) {
+  return 0;
   struct timeval tv;
 
   if (usecs == 0) {
