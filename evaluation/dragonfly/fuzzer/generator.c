
/************************************
     Auto-generated by Chameleon

              Parameters
             ~~~~~~~~~~~~
  Grammar: grammar.chm
  Forbid cycles: false
  Global endianness: native
  Global scheduling: random
  Depth: unlimited
 ************************************/
 
#include <stddef.h>
#include <stdint.h>
#include <endian.h>

#define UNLIKELY(x) __builtin_expect(!!(x), 0)
#define LIKELY(x) __builtin_expect(!!(x), 1)

#ifndef __clang__
#define __builtin_memcpy_inline __builtin_memcpy
#endif

// Mark globals as thread local only if we are doing multithreading
#ifdef MULTITHREADING
#define THREAD_LOCAL __thread
#else
#define THREAD_LOCAL
#endif

// Define the compile-time seed
#ifndef SEED
#define SEED 0x35c6be9ba2548264
#endif

// Define endianness helper functions
#define LITTLE_ENDIAN_16(x) htole16((uint16_t) (x))
#define BIG_ENDIAN_16(x)    htobe16((uint16_t) (x))
#define LITTLE_ENDIAN_32(x) htole32((uint32_t) (x))
#define BIG_ENDIAN_32(x)    htobe32((uint32_t) (x))
#define LITTLE_ENDIAN_64(x) htole64((uint64_t) (x))
#define BIG_ENDIAN_64(x)    htobe64((uint64_t) (x))

// RNG: xorshift64
static THREAD_LOCAL uint64_t rand_state = SEED;

#ifndef DISABLE_rand
static uint64_t rand() {
    uint64_t x = rand_state;
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    return rand_state = x;
}
#else
uint64_t rand();
#endif

#ifndef DISABLE_seed
void ftp_generator_seed(size_t s) {
    if (s) {
        rand_state = (uint64_t) s;
    } else {
        rand_state = SEED;
    }
}
#else
void ftp_generator_seed(size_t);
#endif

// Helper method that writes random data into a buffer
#define MASK_BYTES 0xFFFFFFFFFFFFFFFFUL
#define MASK_STRING 0x7F7F7F7F7F7F7F7FUL
#ifndef DISABLE_random_buffer
static void random_buffer (unsigned char* buf, uint32_t len, uint64_t mask) {
    while (len >= 8) {
        *(uint64_t*)buf = rand() & mask;
        buf += 8; len -= 8;
    }
    
    while (len >= 4) {
        *(uint32_t*)buf = (uint32_t) (rand() & mask);
        buf += 4; len -= 4;
    }
    
    while (len >= 2) {
        *(uint16_t*)buf = (uint16_t) (rand() & mask);
        buf += 2; len -= 2;
    }
    
    while (len >= 1) {
        *buf = (unsigned char) (rand() & mask);
        buf += 1; len -= 1;
    }
}
#else
void random_buffer (unsigned char* buf, uint32_t len, uint64_t mask);
#endif

// Strings from grammar
static const unsigned char string_4041482461632183779[10] = {0x55, 0x53, 0x45, 0x52, 0x20, 0x66, 0x74, 0x70, 0xd, 0xa};
static const unsigned char string_6117162860463527439[6] = {0x50, 0x41, 0x53, 0x53, 0xd, 0xa};

// Forward declarations of containers
static size_t container_0(unsigned char*, size_t);
static size_t container_1(unsigned char*, size_t);

// Definition of containers
static size_t container_0(unsigned char* buf, size_t len) {
    // This container is struct Root
    size_t original_len = len;
    {
        size_t container_len = container_1(buf, len);
        buf += container_len; len -= container_len;
    }
    return original_len - len;
}
static size_t container_1(unsigned char* buf, size_t len) {
    size_t original_len = len;
    uint64_t oneof_selector = rand() % 2;
    switch(oneof_selector) {
        case 0: {
            if (UNLIKELY(len < sizeof(string_4041482461632183779))) {
                goto container_end;
            }
            __builtin_memcpy_inline(buf, string_4041482461632183779, sizeof(string_4041482461632183779));
            buf += sizeof(string_4041482461632183779); len -= sizeof(string_4041482461632183779);
            break;
        }
        case 1: {
            if (UNLIKELY(len < sizeof(string_6117162860463527439))) {
                goto container_end;
            }
            __builtin_memcpy_inline(buf, string_6117162860463527439, sizeof(string_6117162860463527439));
            buf += sizeof(string_6117162860463527439); len -= sizeof(string_6117162860463527439);
            break;
        }
        default: {
            __builtin_unreachable();
        }
    }
    container_end:
    return original_len - len;
}

// Entrypoint for the generator
size_t ftp_generator_generate(unsigned char* buf, size_t len) {
    if (UNLIKELY(!buf || !len)) {
        return 0;
    }
    
    return container_0(buf, len);
}
